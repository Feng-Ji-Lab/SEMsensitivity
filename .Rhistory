#'
#' # Import data
#' df <- PoliticalDemocracy
#'
#' # Build Model
#' model <- '
#'   # measurement model
#'   ind60 =~ x1 + x2 + x3
#'   dem60 =~ y1 + y2 + y3 + y4
#'   dem65 =~ y5 + y6 + y7 + y8
#'   # regressions
#'   dem60 ~ ind60
#'   dem65 ~ ind60 + dem60
#'   # residual correlations
#'   y1 ~~ y5
#'   y2 ~~ y4 + y6
#'   y3 ~~ y7
#'   y4 ~~ y8
#'   y6 ~~ y8
#' '
#'
#' var_one <- 'dem65' # first term
#' var_two <- 'ind60' # second term
#' PAR <- c("dem65~ind60") # full relation
#' threshold <- 10
#'
#' # Fit SEM model
#' fit <- lavaan::sem(model, data = df)
#' summary(fit)
#'
#' # Get Estimates of Parameters from SEM
#' estimates <- parameterEstimates(fit)
#'
#' # Determine the value of the parameter of interest
#' conc <- data.frame(lhs = estimates$lhs, rhs = estimates$rhs, est = estimates$est)
#' int <- conc %>% filter(lhs == var_one & rhs == var_two)
#' par_value <- int$est # this is the value of the parameter of interest
#'
#' # Compute the max number of points to be dropped
#' max_final <- ceiling(threshold * nrow(df) / 100) # perform rounding if necessary
#' N <- nrow(df) # store the number of observations in df for convenience
#'
#' # Determine whether the parameter is negative or positive in order
#' # to assess which direction to perturb it
#' signFactor <- ifelse(par_value >= 0, TRUE, FALSE)
#'
#' Test11_result = Test11(df, model, var_one, var_two, PAR, threshold, fit, estimates,
#' conc, int, par_value, max_final, N, signFactor)
#' summary(Test11_result)
#' }
#' @export
Test11 = function(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor, ...) {
simulated_annealing <- function(num_deletions, current_state = sample(1:N, num_deletions, replace = FALSE), initial_temp = 100, cooling_rate = 0.03, min_temp = 0.1, max_iter = 100) {
num_points <- nrow(df)
current_value <- getValue(current_state,df, model,var_one, var_two)
best_state <- current_state
best_value <- current_value
temp <- initial_temp
for (iter in 1:max_iter) {
if (temp < min_temp) break
new_state <- current_state
add_index <- sample(setdiff(1:num_points, current_state), 1)
remove_index <- sample(current_state, 1)
new_state[new_state == remove_index] <- add_index
new_value <- getValue(new_state,df, model,var_one, var_two)
if (new_value < current_value || runif(1) < exp((current_value - new_value) / temp)) {
current_state <- new_state
current_value <- new_value
}
if (current_value < best_value) {
best_state <- current_state
best_value <- current_value
}
temp <- temp * (1 - cooling_rate)
}
return(list(best_state = best_state, best_value = best_value))
}
# Get initial index
inflX <- replicate(N, 0)
par_values <- replicate(N, 0)
for (droppingP in 1:N) {
par_values[droppingP] <- getValue(droppingP,df, model,var_one, var_two)
inflX[droppingP] <- par_value - par_values[droppingP]
}
infl_sorted <- sort(inflX, decreasing = signFactor, index.return = TRUE)
drops <- infl_sorted$ix[1:max_final]
result <- simulated_annealing(threshold, drops)
annealing_drops <- result$best_state
annealing_value <- result$best_value
resultList <- list()
class(resultList) <- "TestResult11"
resultList$annealingDrops <- annealing_drops
resultList$initialValue <- par_value
resultList$finalValue <- annealing_value
resultList$methodname <- "Simulated Annealing Method to Switch Sign of Parameter"
resultList$testindex <- 11
resultList$PAR <- PAR
resultList$threshold <- threshold
resultList$N <- N
resultList$max_final <- max_final
resultList$par_value <- par_value
return(resultList)
}
#' @export
#' Summary function for TestResult11
summary.TestResult11 <- function(object, ...) {
cat("Summary of Simulated Annealing Method to Switch Sign of Parameter Results:\n")
if (!is.null(object$finalValue)) {
cat(sprintf("Method Name: %s \n", object$methodname))
cat(sprintf("Path: %s \n", object$PAR))
cat(sprintf("Original Value: %f \n", object$initialValue))
cat(sprintf("Original Number of Samples: %d \n", object$N))
cat(sprintf("Drop Points Percentage: %d \n", object$threshold))
cat(sprintf("Dropped Number of Samples: %d \n", length(object$annealingDrops)))
cat(sprintf("New Parameter Value: %f \n", object$finalValue))
cat("Simulated annealing drop points list: \n")
print(object$annealingDrops)
cat(sprintf("Using the simulated annealing method, dropping %d data points, the parameter was switched from %.4f to %.4f\n", length(object$annealingDrops), object$initialValue, object$finalValue))
} else {
cat("The simulated annealing method was unable to switch the parameter sign.\n")
}
}
summary <- function(object, ...) UseMethod("summary")
summary(Test11_result)
devtools::load_all(".")
Test12_result = Test12(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor)
devtools::load_all(".")
Test12_result = Test12(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor)
devtools::load_all(".")
Test12_result = Test12(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor)
devtools::load_all(".")
Test12_result = Test12(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor)
devtools::load_all(".")
Test12_result = Test12(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor)
devtools::load_all(".")
Test12_result = Test12(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor)
devtools::load_all(".")
Test12_result = Test12(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor)
devtools::load_all(".")
Test12_result = Test12(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor)
summary(Test12_result)
#' @title Use Particle Swarm Optimization (PSO) to Try to Switch Sign of Parameter
#' @description This function uses the Particle Swarm Optimization (PSO) method to iteratively remove data points in order to switch the sign of a specific path in a Structural Equation Modeling (SEM) model.
#' @param df A data frame containing the dataset.
#' @param model A specified SEM model.
#' @param var_one The first variable of interest.
#' @param var_two The second variable of interest.
#' @param PAR The path of interest.
#' @param threshold The threshold for the percentage of data dropped.
#' @param fit The SEM object.
#' @param estimates The estimates from the SEM model.
#' @param conc A data frame containing the parameter of interest.
#' @param int The value of the path of interest.
#' @param par_value The original value of the parameter of interest.
#' @param max_final The maximum number of influential data points to consider.
#' @param N The total number of data points.
#' @param signFactor A factor indicating the direction of parameter change (positive or negative).
#' @param ... Other arguments.
#' @importFrom lavaan sem
#' @import dplyr
#' @import semfindr
#' @importFrom stats vcov
#' @importFrom lavaan lavInspect
#' @importFrom lavaan parameterEstimates
#' @return A list of class \code{TestResult12} containing:
#' \item{psoDrops}{The indices of the most influential data points selected by the PSO method.}
#' \item{initialValue}{The original value of the parameter.}
#' \item{finalValue}{The final value of the parameter after applying the PSO method.}
#' \item{methodname}{The name of the method used.}
#' \item{testindex}{The index of the test performed.}
#' \item{PAR}{The path of interest that was evaluated.}
#' \item{threshold}{The threshold used for the percentage of dropped points.}
#' \item{N}{The total number of data points.}
#' \item{max_final}{The maximum number of points allowed to be dropped.}
#' \item{par_value}{The original value of the parameter.}
#' @examples
#' \dontrun{
#' library(lavaan)
#' library(dplyr)
#' library(semfindr)
#' library(R.utils)
#' library(simsem)
#'
#' # Import data
#' df <- PoliticalDemocracy
#'
#' # Build Model
#' model <- '
#'   # measurement model
#'   ind60 =~ x1 + x2 + x3
#'   dem60 =~ y1 + y2 + y3 + y4
#'   dem65 =~ y5 + y6 + y7 + y8
#'   # regressions
#'   dem60 ~ ind60
#'   dem65 ~ ind60 + dem60
#'   # residual correlations
#'   y1 ~~ y5
#'   y2 ~~ y4 + y6
#'   y3 ~~ y7
#'   y4 ~~ y8
#'   y6 ~~ y8
#' '
#'
#' var_one <- 'dem65' # first term
#' var_two <- 'ind60' # second term
#' PAR <- c("dem65~ind60") # full relation
#' threshold <- 10
#'
#' # Fit SEM model
#' fit <- lavaan::sem(model, data = df)
#' summary(fit)
#'
#' # Get Estimates of Parameters from SEM
#' estimates <- parameterEstimates(fit)
#'
#' # Determine the value of the parameter of interest
#' conc <- data.frame(lhs = estimates$lhs, rhs = estimates$rhs, est = estimates$est)
#' int <- conc %>% filter(lhs == var_one & rhs == var_two)
#' par_value <- int$est # this is the value of the parameter of interest
#'
#' # Compute the max number of points to be dropped
#' max_final <- ceiling(threshold * nrow(df) / 100) # perform rounding if necessary
#' N <- nrow(df) # store the number of observations in df for convenience
#'
#' # Determine whether the parameter is negative or positive in order
#' # to assess which direction to perturb it
#' signFactor <- ifelse(par_value >= 0, TRUE, FALSE)
#'
#' Test12_result = Test12(df, model, var_one, var_two, PAR, threshold, fit, estimates,
#' conc, int, par_value, max_final, N, signFactor)
#' summary(Test12_result)
#' }
#' @export
Test12 = function(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor, ...) {
ParticleClass <- setRefClass(
"ParticleClass", # 使用不同的类名
fields = list(
position = "numeric",
velocity = "numeric",
best_position = "numeric",
best_value = "numeric"
),
where = globalenv(),
methods = list(
initialize = function(num_points, num_deletions, tposition = sample(1:num_points, num_deletions, replace = FALSE)) {
position <<- tposition
velocity <<- runif(num_deletions, -1, 1)
best_position <<- position
best_value <<- Inf
},
update_velocity = function(global_best_position, w, c1, c2) {
r1 <- runif(length(position))
r2 <- runif(length(position))
cognitive_component <- c1 * r1 * (best_position - position)
social_component <- c2 * r2 * (global_best_position - position)
velocity <<- w * velocity + cognitive_component + social_component
},
update_position = function(num_points) {
position <<- round(position + velocity)
position[position < 1] <<- 1
position[position > num_points] <<- num_points
position <<- unique(position)
if (length(position) < max_final) {
position <<- c(position, sample(setdiff(1:num_points, position), max_final - length(position)))
} else if (length(position) > max_final) {
position <<- sample(position, max_final)
}
},
evaluate = function(df, model, var_one, var_two) {
current_value <- getValue(position,df, model,var_one, var_two)
if (current_value < best_value) {
best_value <<- current_value
best_position <<- position
}
return(current_value)
}
)
)
pso_minimize <- function(current_state = sample(1:num_points, num_deletions, replace = FALSE), num_deletions, num_particles = 10, max_iter = 30, w = 0.5, c1 = 1.5, c2 = 1.5) {
num_points <- nrow(df)
particles <- vector("list", num_particles)
particles[[1]] = ParticleClass$new(num_points, num_deletions, current_state)
for (i in 2:num_particles) {
particles[[i]] <- ParticleClass$new(num_points, num_deletions)
}
global_best_value <- Inf
global_best_position <- NULL
for (iter in 1:max_iter) {
for (particle in particles) {
current_value <- particle$evaluate(df, model, var_one, var_two)
if (current_value < global_best_value) {
global_best_value <- current_value
global_best_position <- particle$position
}
}
for (particle in particles) {
particle$update_velocity(global_best_position, w, c1, c2)
particle$update_position(num_points)
}
}
return(list(best_position = global_best_position, best_value = global_best_value))
}
# Get initial index
inflX <- replicate(N, 0)
par_values <- replicate(N, 0)
for (droppingP in 1:N) {
par_values[droppingP] <- getValue(droppingP,df, model,var_one, var_two)
inflX[droppingP] <- par_value - par_values[droppingP]
}
infl_sorted <- sort(inflX, decreasing = signFactor, index.return = TRUE)
drops <- infl_sorted$ix[1:max_final]
result <- pso_minimize(drops, num_deletions = max_final)
pso_value <- result$best_value
pso_drops <- result$best_position
resultList <- list()
class(resultList) <- "TestResult12"
resultList$psoDrops <- pso_drops
resultList$initialValue <- par_value
resultList$finalValue <- pso_value
resultList$methodname <- "Particle Swarm Optimization (PSO) to Switch Sign of Parameter"
resultList$testindex <- 12
resultList$PAR <- PAR
resultList$threshold <- threshold
resultList$N <- N
resultList$max_final <- max_final
resultList$par_value <- par_value
return(resultList)
}
#' @export
#' Summary function for TestResult12
summary.TestResult12 <- function(object, ...) {
cat("Summary of Particle Swarm Optimization (PSO) Method to Switch Sign of Parameter Results:\n")
if (!is.null(object$finalValue)) {
cat(sprintf("Method Name: %s \n", object$methodname))
cat(sprintf("Path: %s \n", object$PAR))
cat(sprintf("Original Value: %f \n", object$initialValue))
cat(sprintf("Original Number of Samples: %d \n", object$N))
cat(sprintf("Drop Points Percentage: %d \n", object$threshold))
cat(sprintf("Dropped Number of Samples: %d \n", length(object$psoDrops)))
cat(sprintf("New Parameter Value: %f \n", object$finalValue))
cat("PSO drop points list: \n")
print(object$psoDrops)
cat(sprintf("Using the PSO method, dropping %d data points, the parameter was switched from %.4f to %.4f\n", length(object$psoDrops), object$initialValue, object$finalValue))
} else {
cat("The PSO method was unable to switch the parameter sign.\n")
}
}
summary <- function(object, ...) UseMethod("summary")
Test12_result = Test12(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor)
summary(Test12_result)
document()
check()
check()
devtools::load_all(".")
check()
devtools::load_all(".")
# Load packages
library(lavaan)
library(dplyr)
#library(tidyverse)
#library(gridExtra)
library(semfindr) #to install enter remotes::install_github("sfcheung/semfindr")
library(R.utils) #necessary for the negamax algorithm
#library(semPlot)
#library(mirt)
# library(simsem)
############################# USER INPUTS ######################
#Import data
df <- PoliticalDemocracy
###Build Model###
model <- '
# measurement model
ind60 =~ x1 + x2 + x3
dem60 =~ y1 + y2 + y3 + y4
dem65 =~ y5 + y6 + y7 + y8
# regressions
dem60 ~ ind60
dem65 ~ ind60 + dem60
# residual correlations
y1 ~~ y5
y2 ~~ y4 + y6
y3 ~~ y7
y4 ~~ y8
y6 ~~ y8
'
equalCons <- 0 #specify number of equality constraints in model (for calculations)
var_one = 'dem65' #first term
var_two = 'ind60' #second term
PAR <- c("dem65~ind60") #full relation
#################### SELECT INFLUENCE ANALYSIS PARAMETERS
###CHANGE ME - What parameter you are interested in###
test1 <- T #Exact method
test2 <- T #Approximate method
test3 <- T #Sign switch test
test4 <- T #Depth method
test5 <- T #Combined method
test6 <- F #Fit index tests
test7 <- T #Pruned Negamax method
test8 <- T #Depth method for switching sign
test9 <- T #Negamax method for switching sign
test10 <- F #Simple Depth for Fit Metrics
test11 <- T #anneal search method
test12 <- T #pso method
test13 <- T #brute force with cut method
##Change me - 'Hessian' or 'Covariance' Approximation Method
calcMeth <- 'Hessian'
###CHANGE ME - percentage of data points to drop
threshold <- 10
#################################################################################
#Fit SEM model
fit <- lavaan::sem(model, data=df)
summary(fit)
###Get Estimates of Parameters from SEM###
estimates <- parameterEstimates(fit)
###Determine The Value of The Parameter of Interest
conc <- data.frame(c(estimates$lhs), c(estimates$rhs), c(estimates$est), val = c(estimates$est))
int <- conc %>% filter_all(any_vars(. %in% c(var_one))) %>% filter_all(any_vars(. %in% c(var_two)))
par_value <- int$c.estimates.est. #this is the value of the parameter of interest
###Compute max number of points to be dropped###
max_final <- ceiling(threshold*nrow(df)/100) #perform rounding if necessary
N = nrow(df) #store number of observations in df for convenience
#Determine whether parameter is negative or positive in order
#to assess which direction to perturb it
if (par_value >= 0){
signFactor <- T } else {signFactor <- F
}
# .SEMClusterEnv$getValueWithMemory = myMemorize(getValueInternal)
## BEGIN TESTS ##
###TEST 13 - brute force with cut method ###################################################
if (exists('test13') && test13 == T){
# 初始化最好的组合
initialize_best_combinations <- function() {
best_combinations <- list()
best_values <- numeric()
return(list(best_combinations = best_combinations, best_values = best_values))
}
# 更新最好的组合
update_best_combinations <- function(best_combinations, best_values, new_combination, new_value, max_best) {
if (length(best_values) < max_best || new_value < max(best_values)) {
if (length(best_values) >= max_best) {
max_index <- which.max(best_values)
best_combinations[[max_index]] <- new_combination
best_values[max_index] <- new_value
} else {
best_combinations <- c(best_combinations, list(new_combination))
best_values <- c(best_values, new_value)
}
}
return(list(best_combinations = best_combinations, best_values = best_values))
}
# 逐步生成组合并保留最好的组合
generate_combinations <- function(n, k, max_best) {
best <- initialize_best_combinations()
# 初始化一位数组合
for (i in 1:n) {
value <- getValue(i)
best <- update_best_combinations(best$best_combinations, best$best_values, c(i), value, max_best)
}
# 逐步增加组合的长度
for (depth in 2:k) {
new_best_combinations <- list()
new_best_values <- numeric()
for (combo in best$best_combinations) {
for (i in setdiff(1:n, combo)) {
new_combination <- c(combo, i)
value <- getValue(new_combination)
new_best <- update_best_combinations(new_best_combinations, new_best_values, new_combination, value, max_best)
new_best_combinations <- new_best$best_combinations
new_best_values <- new_best$best_values
}
}
best$best_combinations <- new_best_combinations
best$best_values <- new_best_values
}
return(best)
}
result <- generate_combinations(nrow(df), max_final, 5)
brute_search_value = result$best_value
brute_search_drops = result$best_position
###Print Results###
print(sprintf("The brute search with cut method yields a new parameter value of %f", brute_search_value))
}
Test12_result = Test12(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor)
summary(Test12_result)
check()
check()
devtools::load_all(".")
Test12_result = Test12(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor)
check()
document()
devtools::load_all(".")
Test12_result = Test12(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor)
summary(Test12_result)
check()
check()
devtools::load_all(".")
Test13_result = Test13(df, model, var_one, var_two, PAR, threshold, fit, estimates, conc, int, par_value, max_final, N, signFactor)
summary(Test13_result)
document()
summary(Test13_result)
check()
docuement()
document()
build()
summary(Test13_result)
devtools::load_all(".")
check()
documentt()
document()
build()
build_manual()
check()
